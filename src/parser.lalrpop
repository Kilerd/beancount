
use crate::models::*;
use chrono::{NaiveDate};
use crate::error::BeanCountError;
use lalrpop_util::ParseError;

grammar;

extern {
    type Location = usize;
    type Error = BeanCountError;
}

match {
    // Ignore C++-style comments
    r"///[^\n\r]*[\n\r]*" => { },
} else {
    // Other things you want to match
}
else {
    _ // Everything else
}

pub DirectiveExpression: Box<Directive> = {
    OpenExpression,
};
pub OpenExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "open" SPACE+ <account: AccountExpression>  => Box::new(Directive::Open(date, account))
};


pub AccountExpression: Account = {
    "Assets" ":" => Account::Assets(vec![]),
    "Liabilities" => Account::Liabilities,
};




pub DateExpression: NaiveDate = {
    <date:r"\d{4}-\d{1,2}-\d{1,2}"> =>? NaiveDate::parse_from_str(date, "%Y-%m-%d").map_err(|_|ParseError::User {error: BeanCountError::InvalidDate})
}

pub SPACE = {
    " ",
    r"\t"
}