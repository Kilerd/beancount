
use crate::models::*;
use chrono::{NaiveDate};
use crate::error::BeanCountError;
use lalrpop_util::ParseError;

grammar;

extern {
    type Location = usize;
    type Error = BeanCountError;
}

match {
    // Ignore C++-style comments
    r"///[^\n\r]*[\n\r]*" => { },

    r"\d{4}-\d{1,2}-\d{1,2}"
} else {
    // Other things you want to match
}
else {
    _ // Everything else
}

pub DirectiveExpression: Box<Directive> = {
    OpenExpression,
};
pub OpenExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "open" SPACE+ <account: AccountExpression>  => Box::new(Directive::Open(date, account))
};


pub AccountExpression: Account = {
    "Assets" <v:(":" <AccountName>)+>  => Account::Assets(v),
    "Liabilities" => Account::Liabilities,
};


pub AccountName: String = {
    <r"[A-Za-z0-9-]+"> => <>.to_owned()
}



pub DateExpression: NaiveDate = {
    <date:r"\d{4}-\d{1,2}-\d{1,2}"> =>? NaiveDate::parse_from_str(date, "%Y-%m-%d").map_err(|_|ParseError::User {error: BeanCountError::InvalidDate})
}

pub SPACE = {
    r"\s"
}