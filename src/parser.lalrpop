
use crate::models::*;
use chrono::{NaiveDate};
use crate::error::BeanCountError;
use lalrpop_util::ParseError;
use snailquote::unescape;

grammar;

extern {
    type Location = usize;
    type Error = BeanCountError;
}

match {
    // Ignore C++-style comments
    r"///[^\n\r]*[\n\r]*" => { },

    r"\d{4}-\d{1,2}-\d{1,2}"
} else {
    // Other things you want to match
}
else {
    _ // Everything else
}

pub DirectiveExpression: Box<Directive> = {
    OpenExpression,
    NoteExpression,
};
pub OpenExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "open" SPACE+ <account: AccountExpression>  => Box::new(Directive::Open(date, account))
};

pub NoteExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "note" SPACE+ <account: AccountExpression> SPACE+ <note: StringExpression>  => Box::new(Directive::Note(date, account, note))
};





pub StringExpression: String = {
    <r#""(\\(["\\/bfnrt]|u[a-fA-F0-9]{4})|[^"\\\x00-\x1F\x7F]+)*""#> => unescape(<>).unwrap()
}

pub AccountExpression: Account = {
    "Assets" <v:(":" <AccountName>)+>  => Account::Assets(v),
    "Liabilities" <v:(":" <AccountName>)+> => Account::Liabilities(v),
    "Equity" <v:(":" <AccountName>)+> => Account::Equity(v),
    "Income" <v:(":" <AccountName>)+> => Account::Income(v),
    "Expenses" <v:(":" <AccountName>)+> => Account::Expenses(v),
};


pub AccountName: String = {
    <r"(([^\x00-\x9F])|([A-Za-z0-9-]))+"> => <>.to_owned()
}



pub DateExpression: NaiveDate = {
    <date:r"\d{4}-\d{1,2}-\d{1,2}"> =>? NaiveDate::parse_from_str(date, "%Y-%m-%d").map_err(|_|ParseError::User {error: BeanCountError::InvalidDate})
}

pub SPACE = {
    " ",
    r"\t"
}