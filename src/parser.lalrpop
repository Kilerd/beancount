
use crate::models::*;
use chrono::{NaiveDate};
use crate::error::BeanCountError;
use lalrpop_util::ParseError;
use snailquote::unescape;
use std::str::FromStr;

grammar;

extern {
    type Location = usize;
    type Error = BeanCountError;
}

match {
    // Ignore C++-style comments
    r"///[^\n\r]*[\n\r]*" => { },

    r"\d{4}-\d{1,2}-\d{1,2}",

    r"[A-Z][A-Z0-9_\-'\.]{0,22}[A-Z0-9]"

} else {
    // Other things you want to match
}
else {
    _ // Everything else
}

Comma<T>: Vec<T> = { // (1)
    <v:(<T> "," SPACE*)*> <e:T> => { // (2)
        let mut v = v;
        v.push(e);
        v
    }
};



pub DirectiveExpression: Box<Directive> = {
    OpenExpression,
    NoteExpression,
    CloseExpression,
    CommodityExpression,
    <TransactionExpression> => Box::new(Directive::Transaction(<>)),
}

pub OpenExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "open" SPACE+ <account: AccountExpression> <commodities: (SPACE+ <Comma<Commodity>>)?> SPACE*  => Box::new(Directive::Open(date, account, commodities))
}

pub NoteExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "note" SPACE+ <account: AccountExpression> SPACE+ <note: StringExpression> SPACE* => Box::new(Directive::Note(date, account, note))
}

pub CloseExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "close" SPACE+ <account: AccountExpression> SPACE*  => Box::new(Directive::Close(date, account))
}

pub CommodityExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "commodity" SPACE+ <commodity: Commodity> SPACE*
      <v:("\n" SPACE SPACE+ <AttributeKey> SPACE* ":" SPACE* <StringExpression>)*>

      => Box::new(Directive::Commodity(date, commodity,  v.into_iter().collect()))
}

pub TransactionExpression: Transaction = {
    <date: DateExpression> SPACE+ <flag: FlagExpression> SPACE+ <pn: (<StringExpression>  <(SPACE* ("|" SPACE+)? <StringExpression>)?>)?>
    <v:("\n" SPACE SPACE+ <(<FlagExpression> SPACE*)?> <AccountExpression> SPACE+ <Amount?> )*>

    => Transaction::from_parser(date, flag, pn, v)
}


pub FlagExpression: Flag = {
    "!" => Flag::from_str(<>).unwrap(),
    "*" => Flag::from_str(<>).unwrap()
}

pub Amount: String = {

r"[+-]?\d+(\.\d+)? +[A-Z][A-Z0-9_\-'\.]{0,22}[A-Z0-9]"    => <>.to_owned()
}


pub AttributeKey: String = {
 <r"([^\x00-\x9F]|[A-Za-z0-9-])+"> => <>.to_owned()
}


pub StringExpression: String = {
    <r#""(\\(["\\/bfnrt]|u[a-fA-F0-9]{4})|[^"\\\x00-\x1F\x7F]+)*""#> => unescape(<>).unwrap()
}

pub AccountExpression: Account = {
    "Assets" <v:AccountName+>  => Account::new(AccountType::Assets, v),
    "Liabilities" <v:AccountName+> => Account::new(AccountType::Liabilities, v),
    "Equity" <v:AccountName+> => Account::new(AccountType::Equity, v),
    "Income" <v:AccountName+> => Account::new(AccountType::Income, v),
    "Expenses" <v:AccountName+> => Account::new(AccountType::Expenses, v),
};


pub AccountName: String = {
    <r":([^\x00-\x9F]|[A-Za-z0-9-])+"> => <>[1..<>.len()].to_owned()
}



pub Commodity: String = {
    <r"[A-Z][A-Z0-9_\-'\.]{0,22}[A-Z0-9]"> => <>.to_owned()
}


pub DateExpression: NaiveDate = {
    <date:r"\d{4}-\d{1,2}-\d{1,2}"> =>? NaiveDate::parse_from_str(date, "%Y-%m-%d").map_err(|_|ParseError::User {error: BeanCountError::InvalidDate})
}

pub SPACE = {
    " ",
    r"\t"
}