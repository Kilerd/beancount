
use crate::models::*;
use chrono::{NaiveDate};
use crate::error::BeanCountError;
use lalrpop_util::ParseError;
use snailquote::unescape;
use std::str::FromStr;
use bigdecimal::BigDecimal;
grammar;

extern {
    type Location = usize;
    type Error = BeanCountError;
}

match {
    // Ignore C++-style comments
    r"///[^\n\r]*[\n\r]*" => { },

    r"\d{4}-\d{1,2}-\d{1,2}",

    r"[A-Z][A-Z0-9_\-'\.]{0,22}[A-Z0-9]"

} else {
    // Other things you want to match
}
else {
    _ // Everything else
}

Comma<T>: Vec<T> = { // (1)
    <v:(<T> "," SPACE*)*> <e:T> => { // (2)
        let mut v = v;
        v.push(e);
        v
    }
};



pub DirectiveExpression: Box<Directive> = {
    OptionExpression,
    OpenExpression,
    NoteExpression,
    CloseExpression,
    CommodityExpression,
    <TransactionExpression> => Box::new(Directive::Transaction(<>)),
    PadExpression,
    BalanceExpression,
    DocumentExpression,
    PriceExpression,
    EventExpression,
    PluginExpression,
    IncludeExpression,
    CustomExpression,
}

pub OptionExpression: Box<Directive> = {
    "option" SPACE+ <key: StringExpression> SPACE+ <value: StringExpression> => Box::new(Directive::Option(key, value))
}

pub PluginExpression: Box<Directive> = {
    "plugin" SPACE+ <module_name: StringExpression> <config: (SPACE+ <StringExpression>)?> => Box::new(Directive::Plugin(module_name, config))
}

pub IncludeExpression: Box<Directive> = {
    "include" SPACE+ <file_path: StringExpression>=> Box::new(Directive::Include(file_path))
}

pub OpenExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "open" SPACE+ <account: AccountExpression> <commodities: (SPACE+ <Comma<Commodity>>)?> SPACE*  => Box::new(Directive::Open(date, account, commodities))
}

pub NoteExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "note" SPACE+ <account: AccountExpression> SPACE+ <note: StringExpression> SPACE* => Box::new(Directive::Note(date, account, note))
}

pub CloseExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "close" SPACE+ <account: AccountExpression> SPACE*  => Box::new(Directive::Close(date, account))
}

pub CommodityExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "commodity" SPACE+ <commodity: Commodity> SPACE*
      <v:("\n" SPACE SPACE+ <AttributeKey> SPACE* ":" SPACE* <StringExpression>)*>

      => Box::new(Directive::Commodity(date, commodity,  v.into_iter().collect()))
}

pub TransactionExpression: Transaction = {
    <date: DateExpression> SPACE+ <flag: FlagExpression> SPACE+ <pn: (<StringExpression> SPACE*  <(("|" SPACE+)? <StringExpression> SPACE*)?>)?> <tags: ("#" <AttributeKey> SPACE*)*> <links: ("^" <AttributeKey> SPACE*)*>
    <v:("\n" SPACE SPACE+ <(<FlagExpression> SPACE*)?> <AccountExpression> <(SPACE+ <Amount>)?> <(SPACE+ "@" SPACE* <Amount>)?> <(SPACE+ "@@" SPACE* <Amount>)?> )*>

    => {
    let lines = v.into_iter().map(|line| {
        let (flag, account, amount, single_price, total_price) = line;
        let flag = flag.unwrap_or(Flag::Complete);
        let cost = None; // todo implement cost;
        TransactionLine{flag, account, amount, cost, single_price, total_price}
    }).collect();
    Transaction::from_parser(date, flag, pn, tags, links, lines)
    }
}

pub PadExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "pad" SPACE+ <from: AccountExpression> SPACE+ <to: AccountExpression> SPACE* => Box::new(Directive::Pad(date, from, to))
}

pub BalanceExpression: Box<Directive> = {
     <date: DateExpression> SPACE+ "balance" SPACE+ <account: AccountExpression> SPACE+ <amount: Amount> SPACE* => Box::new(Directive::Balance(date, account, amount))
}


pub DocumentExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "document" SPACE+ <account: AccountExpression> SPACE+ <note: StringExpression> SPACE* => Box::new(Directive::Document(date, account, note))
}


pub PriceExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "price" SPACE+ <commodity: Commodity> SPACE+ <amount: Amount> SPACE* => Box::new(Directive::Price(date, commodity, amount))
}

pub EventExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "event" SPACE+ <name: StringExpression> SPACE+ <description: StringExpression> SPACE* => Box::new(Directive::Event(date, name, description))
}

pub CustomExpression: Box<Directive> = {
    <date: DateExpression> SPACE+ "custom" SPACE+ <name: StringExpression> <config: (SPACE+ <CustomConfigItem>)+> => Box::new(Directive::Custom(name, config))
}

pub CustomConfigItem: String = {
    StringExpression,
    AccountExpression => <>.to_string(),
    Commodity,
    AttributeKey,
}

pub FlagExpression: Flag = {
    "!" => Flag::from_str(<>).unwrap(),
    "*" => Flag::from_str(<>).unwrap()
}

pub Amount: (BigDecimal, String) = {
    r"[+-]?\d+(\.\d+)? +[A-Z][A-Z0-9_\-'\.]{0,22}[A-Z0-9]"    => amount_parse(<>)
}


pub AttributeKey: String = {
 <r"([^\x00-\x9F]|[A-Za-z0-9-])+"> => <>.to_owned()
}


pub StringExpression: String = {
    <r#""(\\(["\\/bfnrt]|u[a-fA-F0-9]{4})|[^"\\\x00-\x1F\x7F]+)*""#> => unescape(<>).unwrap()
}

pub AccountExpression: Account = {
    "Assets" <v:AccountName+>  => Account::new(AccountType::Assets, v),
    "Liabilities" <v:AccountName+> => Account::new(AccountType::Liabilities, v),
    "Equity" <v:AccountName+> => Account::new(AccountType::Equity, v),
    "Income" <v:AccountName+> => Account::new(AccountType::Income, v),
    "Expenses" <v:AccountName+> => Account::new(AccountType::Expenses, v),
};


pub AccountName: String = {
    <r":([^\x00-\x9F]|[A-Za-z0-9-])+"> => <>[1..<>.len()].to_owned()
}



pub Commodity: String = {
    <r"[A-Z][A-Z0-9_\-'\.]{0,22}[A-Z0-9]"> => <>.to_owned()
}


pub DateExpression: NaiveDate = {
    <date:r"\d{4}-\d{1,2}-\d{1,2}"> =>? NaiveDate::parse_from_str(date, "%Y-%m-%d").map_err(|_|ParseError::User {error: BeanCountError::InvalidDate})
}

pub SPACE = {
    " ",
    r"\t"
}